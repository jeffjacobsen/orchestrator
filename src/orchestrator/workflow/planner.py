"""Task decomposition and planning."""

import json
import logging
from typing import Dict, List, Any, Optional
from orchestrator.core.types import AgentRole, OrchestratorTask
from orchestrator.core.agent_manager import AgentManager
from orchestrator.core.prompts import get_workflow_planner_prompt

logger = logging.getLogger(__name__)


class TaskPlanner:
    """
    Decomposes high-level tasks into agent-specific work.

    This is a critical component that enables the orchestrator to:
    - Break down complex prompts into concrete steps
    - Assign specialized agents to appropriate tasks
    - Determine optimal task ordering and dependencies
    """

    def __init__(
        self,
        working_directory: Optional[str] = None,
        use_ai_planner: bool = True,
    ) -> None:
        """
        Initialize TaskPlanner.

        Args:
            working_directory: Working directory for planner agents
            use_ai_planner: If True, use AI PLANNER agent; if False, use template-based planning
        """
        self.working_directory = working_directory
        self.use_ai_planner = use_ai_planner
        self.agent_manager = AgentManager(working_directory=working_directory)

        # Keep templates as fallback for when AI planner is disabled
        self.planning_templates = self._load_planning_templates()

    def _load_planning_templates(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Load planning templates for common task patterns.

        In production, these could be:
        - Learned from previous successful workflows
        - Loaded from configuration files
        - Generated by an LLM planner

        Templates are organized by task type and complexity:
        - simple_*: Skip Analyst, minimal agents (Builder + Tester)
        - feature_implementation: Full workflow for complex features
        - bug_fix: Root cause analysis required
        """
        return {
            # Simple tasks - no analysis needed, just build and test
            "simple_implementation": [
                {
                    "role": AgentRole.BUILDER,
                    "task": "Implement the requested functionality",
                },
                {
                    "role": AgentRole.TESTER,
                    "task": "Test the implementation",
                },
            ],
            "simple_fix": [
                {
                    "role": AgentRole.BUILDER,
                    "task": "Fix the issue",
                },
                {
                    "role": AgentRole.TESTER,
                    "task": "Verify the fix works",
                },
            ],
            # Complex tasks - full workflow with analysis
            "feature_implementation": [
                {
                    "role": AgentRole.ANALYST,
                    "task": "Research requirements and analyze existing codebase",
                },
                {
                    "role": AgentRole.PLANNER,
                    "task": "Create implementation plan based on analysis",
                },
                {
                    "role": AgentRole.BUILDER,
                    "task": "Implement the feature following the plan",
                },
                {
                    "role": AgentRole.TESTER,
                    "task": "Write and run tests for the new feature",
                },
                {
                    "role": AgentRole.REVIEWER,
                    "task": "Review that implementation follows the plan and meets quality standards",
                },
            ],
            "bug_fix": [
                {
                    "role": AgentRole.ANALYST,
                    "task": "Investigate and analyze the root cause of the bug",
                },
                {
                    "role": AgentRole.PLANNER,
                    "task": "Create a fix plan based on root cause analysis",
                },
                {
                    "role": AgentRole.BUILDER,
                    "task": "Implement the fix following the plan",
                },
                {
                    "role": AgentRole.TESTER,
                    "task": "Test the fix and add regression tests",
                },
                {
                    "role": AgentRole.REVIEWER,
                    "task": "Review that the fix follows the plan and resolves the issue",
                },
            ],
            "code_review": [
                {
                    "role": AgentRole.ANALYST,
                    "task": "Analyze code changes and identify areas to review",
                },
                {
                    "role": AgentRole.PLANNER,
                    "task": "Create review plan with checklist and priorities",
                },
                {
                    "role": AgentRole.REVIEWER,
                    "task": "Review code following the plan for quality, security, and best practices",
                },
                {
                    "role": AgentRole.TESTER,
                    "task": "Verify test coverage is adequate",
                },
            ],
            "documentation": [
                {
                    "role": AgentRole.ANALYST,
                    "task": "Research and understand component behavior, APIs, and usage",
                },
                {
                    "role": AgentRole.PLANNER,
                    "task": "Create documentation plan with structure and coverage",
                },
                {
                    "role": AgentRole.DOCUMENTER,
                    "task": "Write comprehensive documentation following the plan",
                },
                {
                    "role": AgentRole.REVIEWER,
                    "task": "Review documentation for accuracy and completeness",
                },
            ],
        }

    def _estimate_task_complexity(self, description: str) -> str:
        """
        Estimate if a task is simple or complex to determine workflow.

        Simple tasks are those that:
        - Are short and focused (< 50 words)
        - Use simple action verbs (write, create, add, fix)
        - Don't require deep codebase analysis
        - Don't involve architecture changes

        Complex tasks involve:
        - Refactoring or redesigning systems
        - Multiple file changes across directories
        - Architecture or design decisions
        - Research-heavy requirements

        Args:
            description: Task description

        Returns:
            "simple" or "complex"
        """
        description_lower = description.lower()
        word_count = len(description.split())

        # Complex task indicators
        complex_keywords = [
            "refactor",
            "redesign",
            "migrate",
            "architecture",
            "research",
            "analyze",
            "investigate",
            "comprehensive",
            "system",
            "multiple",
        ]

        # Simple task indicators
        simple_keywords = [
            "write a",
            "create a simple",
            "add a simple",
            "fix a simple",
            "simple function",
            "quick fix",
        ]

        # Check for complexity indicators
        if any(keyword in description_lower for keyword in complex_keywords):
            return "complex"

        # Check for simplicity indicators
        if any(keyword in description_lower for keyword in simple_keywords):
            return "simple"

        # Use word count as fallback
        if word_count < 50:
            return "simple"

        return "complex"

    async def plan_task(
        self,
        task_id: str,
        description: str,
        task_type: str = "custom",
    ) -> OrchestratorTask:
        """
        Create a task plan with subtasks decomposed by specialized roles.

        This method transforms a high-level task description into a structured
        workflow with specific subtasks assigned to appropriate agent roles.
        It uses predefined templates for common task patterns.

        Args:
            task_id: Unique identifier for the task
            description: High-level task description
            task_type: Type of task (feature_implementation, bug_fix, code_review,
                      documentation, or custom)

        Returns:
            OrchestratorTask with decomposed subtasks, each assigned to a specialized
            agent role with context and description.

        Examples:
            Feature implementation decomposition:

            >>> from orchestrator.workflow.planner import TaskPlanner
            >>> planner = TaskPlanner()
            >>>
            >>> # Plan a feature implementation
            >>> task = planner.plan_task(
            ...     task_id="task-001",
            ...     description="Add OAuth2 authentication to the API",
            ...     task_type="feature_implementation"
            ... )
            >>>
            >>> print(f"Task: {task.description}")
            >>> print(f"Subtasks: {len(task.subtasks)}")
            >>> for i, subtask in enumerate(task.subtasks, 1):
            ...     print(f"{i}. [{subtask['role'].value}] {subtask['task']}")
            Task: Add OAuth2 authentication to the API
            Subtasks: 5
            1. [analyst] Research requirements and analyze existing codebase
            2. [planner] Create implementation plan based on analysis
            3. [builder] Implement the feature following the plan
            4. [tester] Write and run tests for the new feature
            5. [reviewer] Review that implementation follows the plan and meets quality standards

            Bug fix decomposition:

            >>> # Plan a bug fix workflow
            >>> bug_task = planner.plan_task(
            ...     task_id="bug-042",
            ...     description="Fix memory leak in background job processor",
            ...     task_type="bug_fix"
            ... )
            >>>
            >>> print(f"Bug fix workflow for: {bug_task.description}")
            >>> for subtask in bug_task.subtasks:
            ...     role = subtask['role'].value
            ...     desc = subtask['description']
            ...     print(f"  {role}: {desc}")
            Bug fix workflow for: Fix memory leak in background job processor
              analyst: Investigate and analyze the root cause of the bug: Fix memory leak...
              planner: Create a fix plan based on root cause analysis: Fix memory leak...
              builder: Implement the fix following the plan: Fix memory leak...
              tester: Test the fix and add regression tests: Fix memory leak...
              reviewer: Review that the fix follows the plan and resolves the issue: Fix...

            Code review decomposition:

            >>> # Plan a code review workflow
            >>> review_task = planner.plan_task(
            ...     task_id="review-pr-123",
            ...     description="Review pull request #123 for security and performance",
            ...     task_type="code_review"
            ... )
            >>>
            >>> print(f"Review workflow: {len(review_task.subtasks)} steps")
            >>> for i, subtask in enumerate(review_task.subtasks, 1):
            ...     print(f"  Step {i}: {subtask['role'].value}")
            Review workflow: 4 steps
              Step 1: analyst
              Step 2: planner
              Step 3: reviewer
              Step 4: tester

            Documentation workflow decomposition:

            >>> # Plan documentation workflow
            >>> doc_task = planner.plan_task(
            ...     task_id="doc-api",
            ...     description="Create comprehensive API documentation",
            ...     task_type="documentation"
            ... )
            >>>
            >>> print(f"Documentation workflow:")
            >>> for subtask in doc_task.subtasks:
            ...     print(f"  - {subtask['role'].value}: {subtask['task']}")
            Documentation workflow:
              - analyst: Research and understand component behavior, APIs, and usage
              - planner: Create documentation plan with structure and coverage
              - documenter: Write comprehensive documentation following the plan
              - reviewer: Review documentation for accuracy and completeness

            Custom task type with no template:

            >>> # Custom task falls back to empty subtasks list
            >>> custom_task = planner.plan_task(
            ...     task_id="custom-001",
            ...     description="Perform custom analysis",
            ...     task_type="custom"
            ... )
            >>>
            >>> print(f"Custom task subtasks: {len(custom_task.subtasks)}")
            >>> print(f"Status: {custom_task.status.value}")
            Custom task subtasks: 0
            Status: created

            Inspecting task structure:

            >>> # Examine the complete task structure
            >>> task = planner.plan_task(
            ...     task_id="task-002",
            ...     description="Optimize database queries",
            ...     task_type="feature_implementation"
            ... )
            >>>
            >>> print(f"Task ID: {task.task_id}")
            >>> print(f"Description: {task.description}")
            >>> print(f"Status: {task.status.value}")
            >>> print(f"Created at: {task.created_at}")
            >>> print(f"Assigned agents: {task.assigned_agents}")
            >>>
            >>> # Each subtask has role, description, and context
            >>> subtask = task.subtasks[0]
            >>> print(f"\nFirst subtask:")
            >>> print(f"  Role: {subtask['role']}")
            >>> print(f"  Description: {subtask['description']}")
            >>> print(f"  Context: {subtask['context']}")
            Task ID: task-002
            Description: Optimize database queries
            Status: created
            Created at: 2025-01-15 10:30:00
            Assigned agents: []

            First subtask:
              Role: AgentRole.ANALYST
              Description: Research requirements and analyze existing codebase: Optimize...
              Context: Optimize database queries

            Task lifecycle tracking:

            >>> # Task starts in CREATED status
            >>> task = planner.plan_task(
            ...     task_id="task-003",
            ...     description="Implement caching layer",
            ...     task_type="feature_implementation"
            ... )
            >>>
            >>> print(f"Initial status: {task.status.value}")
            >>> print(f"Completed at: {task.completed_at}")
            >>> print(f"Result: {task.result}")
            >>>
            >>> # As workflow executes, these fields get populated:
            >>> # - status changes to RUNNING, then COMPLETED/FAILED
            >>> # - assigned_agents list is populated with agent IDs
            >>> # - completed_at is set when done
            >>> # - result contains the TaskResult
            Initial status: created
            Completed at: None
            Result: None

            Comparing different task types:

            >>> # Compare templates for different task types
            >>> task_types = ["feature_implementation", "bug_fix", "code_review", "documentation"]
            >>>
            >>> for task_type in task_types:
            ...     task = planner.plan_task(
            ...         task_id=f"compare-{task_type}",
            ...         description="Sample task",
            ...         task_type=task_type
            ...     )
            ...     roles = [s['role'].value for s in task.subtasks]
            ...     print(f"{task_type}: {' → '.join(roles)}")
            feature_implementation: analyst → planner → builder → tester → reviewer
            bug_fix: analyst → planner → builder → tester → reviewer
            code_review: analyst → planner → reviewer → tester
            documentation: analyst → planner → documenter → reviewer

            Using task plan in workflow execution:

            >>> from orchestrator.core.orchestrator import Orchestrator
            >>>
            >>> # The planner is used internally by orchestrator
            >>> orchestrator = Orchestrator()
            >>>
            >>> # When you call execute(), it uses the planner:
            >>> # task = planner.plan_task(task_id, description, task_type)
            >>> # Then passes to executor for agent creation and execution
            >>>
            >>> # You can also use the planner directly for analysis:
            >>> task = planner.plan_task(
            ...     task_id="analyze-001",
            ...     description="Add new feature",
            ...     task_type="feature_implementation"
            ... )
            >>> print(f"This task will create {len(task.subtasks)} agents")
            This task will create 5 agents
        """
        # Use AI PLANNER agent or fall back to templates
        if self.use_ai_planner:
            try:
                return await self._plan_with_ai_agent(task_id, description, task_type)
            except Exception as e:
                logger.warning(f"AI planner failed, falling back to templates: {e}")
                return self._plan_with_templates(task_id, description, task_type)
        else:
            return self._plan_with_templates(task_id, description, task_type)

    def _plan_with_templates(
        self,
        task_id: str,
        description: str,
        task_type: str = "custom",
    ) -> OrchestratorTask:
        """
        Create a task plan using predefined templates (legacy approach).

        Args:
            task_id: Unique identifier for the task
            description: High-level task description
            task_type: Type of task

        Returns:
            OrchestratorTask with template-based subtasks
        """
        # Estimate task complexity to select appropriate workflow
        complexity = self._estimate_task_complexity(description)

        # Select template based on complexity and task type
        # For simple tasks, use simplified workflows that skip Analyst
        if complexity == "simple":
            if task_type == "feature_implementation":
                template_key = "simple_implementation"
            elif task_type == "bug_fix":
                template_key = "simple_fix"
            else:
                template_key = task_type
        else:
            # Use full workflow for complex tasks
            template_key = task_type

        # Get template or create custom plan
        template = self.planning_templates.get(template_key, None)

        # If no template found, use a sensible default based on complexity
        if template is None:
            logger.warning(f"No template found for task_type='{template_key}', using default workflow")
            # Default to feature_implementation workflow for custom tasks
            if complexity == "simple":
                template = self.planning_templates["simple_implementation"]
            else:
                template = self.planning_templates["feature_implementation"]

        subtasks = []
        for step in template:
            subtasks.append({
                "role": step["role"],
                "description": f"{step['task']}: {description}",
                "context": description,
            })

        return OrchestratorTask(
            task_id=task_id,
            description=description,
            subtasks=subtasks,
        )

    async def _plan_with_ai_agent(
        self,
        task_id: str,
        description: str,
        task_type: str = "custom",
    ) -> OrchestratorTask:
        """
        Create a task plan using AI WORKFLOW PLANNER agent.

        The PLANNER agent analyzes the task and creates an optimized workflow
        with scoped instructions and constraints for each agent.

        Args:
            task_id: Unique identifier for the task
            description: High-level task description
            task_type: Type of task (for context)

        Returns:
            OrchestratorTask with AI-planned subtasks including constraints
        """
        logger.info(f"Planning task '{task_id}' with AI PLANNER agent")

        # Build prompt for WORKFLOW PLANNER
        planner_prompt = f"""Analyze this task and design an optimal workflow:

TASK DESCRIPTION:
{description}

TASK TYPE: {task_type}

WORKING DIRECTORY: {self.working_directory or 'current directory'}

Based on the task analysis framework in your system prompt, determine:
1. Task complexity (simple/medium/complex)
2. Which agents are needed
3. Specific scope and constraints for each agent
4. Execution order (sequential/parallel)
5. Estimated costs

Respond with ONLY valid JSON (no markdown, no explanation)."""

        # Create WORKFLOW PLANNER agent
        planner_agent = await self.agent_manager.create_agent(
            name="Workflow Planner",
            role=AgentRole.PLANNER,
            system_prompt=get_workflow_planner_prompt(),
            working_directory=self.working_directory,
            model="claude-sonnet-4-5-20250929",  # Use Sonnet for planning
            permission_mode="bypassPermissions",
            task_id=task_id,  # Pass task_id for log organization
        )

        # Execute planning
        result = await planner_agent.execute_task(planner_prompt)

        # Clean up the planner agent
        await self.agent_manager.delete_agent(planner_agent.agent_id)

        if not result.success:
            raise RuntimeError(f"PLANNER agent failed: {result.error}")

        # Check if output is empty (potential SDK/timing issue)
        if not result.output or not result.output.strip():
            logger.error("PLANNER returned empty output despite success=True")
            logger.error(f"Agent ID: {planner_agent.agent_id}, Metrics: {result.metrics}")
            raise RuntimeError(
                f"PLANNER agent succeeded but returned empty output. "
                f"This may be a transient SDK issue. Please retry. "
                f"Agent logs: dashboard/backend/agent_logs/{planner_agent.agent_id}_*/"
            )

        # Parse JSON response
        try:
            workflow_plan = self._parse_workflow_plan(result.output)
        except Exception as e:
            logger.error(f"Failed to parse PLANNER output: {e}")
            logger.error(f"Output length: {len(result.output)} characters")
            logger.debug(f"Raw output (first 500 chars): {result.output[:500]}")
            raise RuntimeError(f"Invalid workflow plan from PLANNER: {e}")

        # Log the plan for debugging
        logger.info(f"PLANNER complexity assessment: {workflow_plan['complexity']}")
        logger.info(f"PLANNER rationale: {workflow_plan['rationale']}")
        logger.info(f"PLANNER workflow has {len(workflow_plan['workflow'])} steps")

        # Build subtasks from workflow plan
        subtasks = []
        for step in workflow_plan["workflow"]:
            # Convert agent_role string to AgentRole enum
            try:
                agent_role = AgentRole[step["agent_role"]]
            except KeyError:
                logger.warning(f"Unknown agent role: {step['agent_role']}, skipping")
                continue

            subtasks.append({
                "role": agent_role,
                "description": f"{step['scope']}: {description}",
                "context": description,
                "constraints": step.get("constraints", []),
                "estimated_tokens": step.get("estimated_tokens", 0),
                "execution_mode": step.get("execution_mode", "sequential"),
                "depends_on": step.get("depends_on", []),
            })

        return OrchestratorTask(
            task_id=task_id,
            description=description,
            subtasks=subtasks,
            metadata={
                "complexity": workflow_plan["complexity"],
                "rationale": workflow_plan["rationale"],
                "estimated_cost": workflow_plan.get("total_estimated_cost", 0),
                "skip_reasoning": workflow_plan.get("skip_reasoning", ""),
            },
        )

    def _parse_workflow_plan(self, output: str) -> Dict[str, Any]:
        """
        Parse JSON workflow plan from PLANNER agent output.

        Handles cases where LLM wraps JSON in markdown code blocks.

        Args:
            output: Raw output from PLANNER agent

        Returns:
            Parsed workflow plan dictionary

        Raises:
            ValueError: If JSON is invalid or missing required fields
        """
        # Clean up output - remove markdown code fences if present
        output = output.strip()
        if output.startswith("```json"):
            output = output[7:]  # Remove ```json
        elif output.startswith("```"):
            output = output[3:]  # Remove ```

        if output.endswith("```"):
            output = output[:-3]

        output = output.strip()

        # Parse JSON
        try:
            plan = json.loads(output)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON from PLANNER: {e}")

        # Validate required fields
        required_fields = ["complexity", "rationale", "workflow"]
        for field in required_fields:
            if field not in plan:
                raise ValueError(f"Missing required field: {field}")

        # Validate workflow steps
        if not isinstance(plan["workflow"], list):
            raise ValueError("workflow must be a list")

        for i, step in enumerate(plan["workflow"]):
            required_step_fields = ["agent_role", "scope", "constraints", "execution_mode"]
            for field in required_step_fields:
                if field not in step:
                    raise ValueError(f"Step {i} missing required field: {field}")

        return plan

    def plan_parallel_tasks(
        self,
        task_id: str,
        description: str,
        agent_roles: List[AgentRole],
    ) -> OrchestratorTask:
        """
        Create a plan for parallel execution.

        Args:
            task_id: Unique task identifier
            description: Task description
            agent_roles: Roles that can work in parallel

        Returns:
            Task plan with parallel subtasks
        """
        subtasks = [
            {
                "role": role,
                "description": f"{role.value} work: {description}",
                "parallel": True,
            }
            for role in agent_roles
        ]

        return OrchestratorTask(
            task_id=task_id,
            description=description,
            subtasks=subtasks,
        )

    def estimate_task_complexity(self, description: str) -> Dict[str, Any]:
        """
        Estimate task complexity to determine resource allocation.

        Returns:
            Dict with estimated agents needed, time, cost
        """
        # Simple heuristic - in production, could use ML model
        word_count = len(description.split())

        if word_count < 20:
            complexity = "simple"
            estimated_agents = 1
        elif word_count < 50:
            complexity = "moderate"
            estimated_agents = 2
        else:
            complexity = "complex"
            estimated_agents = 3

        return {
            "complexity": complexity,
            "estimated_agents": estimated_agents,
            "suggested_roles": self._suggest_roles(description),
        }

    def _suggest_roles(self, description: str) -> List[AgentRole]:
        """Suggest appropriate agent roles based on task description."""
        roles = []

        keywords_map = {
            AgentRole.PLANNER: ["plan", "organize", "decompose", "breakdown", "strategy"],
            AgentRole.BUILDER: ["implement", "build", "create", "develop", "code"],
            AgentRole.REVIEWER: ["review", "check", "verify", "validate", "audit"],
            AgentRole.ANALYST: ["analyze", "research", "investigate", "study"],
            AgentRole.TESTER: ["test", "testing", "verify", "validate", "qa"],
            AgentRole.DOCUMENTER: ["document", "docs", "readme", "documentation"],
        }

        description_lower = description.lower()

        for role, keywords in keywords_map.items():
            if any(keyword in description_lower for keyword in keywords):
                roles.append(role)

        # Default to Analyst → Planner → Builder if no specific roles detected
        if not roles:
            roles = [AgentRole.ANALYST, AgentRole.PLANNER, AgentRole.BUILDER]

        return roles
