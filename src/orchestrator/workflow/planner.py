"""Task decomposition and planning."""

from typing import Dict, List, Any
from orchestrator.core.types import AgentRole, OrchestratorTask


class TaskPlanner:
    """
    Decomposes high-level tasks into agent-specific work.

    This is a critical component that enables the orchestrator to:
    - Break down complex prompts into concrete steps
    - Assign specialized agents to appropriate tasks
    - Determine optimal task ordering and dependencies
    """

    def __init__(self) -> None:
        self.planning_templates = self._load_planning_templates()

    def _load_planning_templates(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Load planning templates for common task patterns.

        In production, these could be:
        - Learned from previous successful workflows
        - Loaded from configuration files
        - Generated by an LLM planner
        """
        return {
            "feature_implementation": [
                {
                    "role": AgentRole.ANALYST,
                    "task": "Research requirements and analyze existing codebase",
                },
                {
                    "role": AgentRole.PLANNER,
                    "task": "Create implementation plan based on analysis",
                },
                {
                    "role": AgentRole.BUILDER,
                    "task": "Implement the feature following the plan",
                },
                {
                    "role": AgentRole.TESTER,
                    "task": "Write and run tests for the new feature",
                },
                {
                    "role": AgentRole.REVIEWER,
                    "task": "Review that implementation follows the plan and meets quality standards",
                },
            ],
            "bug_fix": [
                {
                    "role": AgentRole.ANALYST,
                    "task": "Investigate and analyze the root cause of the bug",
                },
                {
                    "role": AgentRole.PLANNER,
                    "task": "Create a fix plan based on root cause analysis",
                },
                {
                    "role": AgentRole.BUILDER,
                    "task": "Implement the fix following the plan",
                },
                {
                    "role": AgentRole.TESTER,
                    "task": "Test the fix and add regression tests",
                },
                {
                    "role": AgentRole.REVIEWER,
                    "task": "Review that the fix follows the plan and resolves the issue",
                },
            ],
            "code_review": [
                {
                    "role": AgentRole.ANALYST,
                    "task": "Analyze code changes and identify areas to review",
                },
                {
                    "role": AgentRole.PLANNER,
                    "task": "Create review plan with checklist and priorities",
                },
                {
                    "role": AgentRole.REVIEWER,
                    "task": "Review code following the plan for quality, security, and best practices",
                },
                {
                    "role": AgentRole.TESTER,
                    "task": "Verify test coverage is adequate",
                },
            ],
            "documentation": [
                {
                    "role": AgentRole.ANALYST,
                    "task": "Research and understand component behavior, APIs, and usage",
                },
                {
                    "role": AgentRole.PLANNER,
                    "task": "Create documentation plan with structure and coverage",
                },
                {
                    "role": AgentRole.DOCUMENTER,
                    "task": "Write comprehensive documentation following the plan",
                },
                {
                    "role": AgentRole.REVIEWER,
                    "task": "Review documentation for accuracy and completeness",
                },
            ],
        }

    def plan_task(
        self,
        task_id: str,
        description: str,
        task_type: str = "custom",
    ) -> OrchestratorTask:
        """
        Create a task plan with subtasks.

        Args:
            task_id: Unique identifier for the task
            description: High-level task description
            task_type: Type of task (feature_implementation, bug_fix, etc.)

        Returns:
            OrchestratorTask with decomposed subtasks
        """
        # Get template or create custom plan
        template = self.planning_templates.get(task_type, [])

        subtasks = []
        for step in template:
            subtasks.append({
                "role": step["role"],
                "description": f"{step['task']}: {description}",
                "context": description,
            })

        return OrchestratorTask(
            task_id=task_id,
            description=description,
            subtasks=subtasks,
        )

    def plan_parallel_tasks(
        self,
        task_id: str,
        description: str,
        agent_roles: List[AgentRole],
    ) -> OrchestratorTask:
        """
        Create a plan for parallel execution.

        Args:
            task_id: Unique task identifier
            description: Task description
            agent_roles: Roles that can work in parallel

        Returns:
            Task plan with parallel subtasks
        """
        subtasks = [
            {
                "role": role,
                "description": f"{role.value} work: {description}",
                "parallel": True,
            }
            for role in agent_roles
        ]

        return OrchestratorTask(
            task_id=task_id,
            description=description,
            subtasks=subtasks,
        )

    def estimate_task_complexity(self, description: str) -> Dict[str, Any]:
        """
        Estimate task complexity to determine resource allocation.

        Returns:
            Dict with estimated agents needed, time, cost
        """
        # Simple heuristic - in production, could use ML model
        word_count = len(description.split())

        if word_count < 20:
            complexity = "simple"
            estimated_agents = 1
        elif word_count < 50:
            complexity = "moderate"
            estimated_agents = 2
        else:
            complexity = "complex"
            estimated_agents = 3

        return {
            "complexity": complexity,
            "estimated_agents": estimated_agents,
            "suggested_roles": self._suggest_roles(description),
        }

    def _suggest_roles(self, description: str) -> List[AgentRole]:
        """Suggest appropriate agent roles based on task description."""
        roles = []

        keywords_map = {
            AgentRole.PLANNER: ["plan", "organize", "decompose", "breakdown", "strategy"],
            AgentRole.BUILDER: ["implement", "build", "create", "develop", "code"],
            AgentRole.REVIEWER: ["review", "check", "verify", "validate", "audit"],
            AgentRole.ANALYST: ["analyze", "research", "investigate", "study"],
            AgentRole.TESTER: ["test", "testing", "verify", "validate", "qa"],
            AgentRole.DOCUMENTER: ["document", "docs", "readme", "documentation"],
        }

        description_lower = description.lower()

        for role, keywords in keywords_map.items():
            if any(keyword in description_lower for keyword in keywords):
                roles.append(role)

        # Default to Analyst → Planner → Builder if no specific roles detected
        if not roles:
            roles = [AgentRole.ANALYST, AgentRole.PLANNER, AgentRole.BUILDER]

        return roles
